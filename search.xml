<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[黑马Vue学习笔记02]]></title>
    <url>%2F2019%2F08%2F29%2Fvue-study-02%2F</url>
    <content type="text"><![CDATA[添加数据到列表 直接从data中获取id和name 组织出一个对象 调用数组的方法,将该对象添加到data中的list数组中 在Vue中,已经实现了数据的双向绑定,每当我们修改了data中的数据,Vue会自动将最新数据渲染到页面中去相关核心代码如下1234567891011121314151617181920212223242526272829303132333435363738394041&lt;tr v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; id: &apos;&apos;, name: &apos;&apos;, keyWords: &apos;&apos;, list: [&#123; id: 1, name: &apos;保时捷&apos;, ctime: new Date() &#125;, &#123; id: 2, name: &apos;本田&apos;, ctime: new Date() &#125;, &#123; id: 3, name: &apos;丰田&apos;, ctime: new Date() &#125;, ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name, ctime: new Date() &#125;) &#125; &#125; &#125;); &lt;/script&gt; 列表删除操作 根据id找到相关数据的索引在数组的some方法中,如果return true,就会立即终止这个数组的后续循环12345678del(id) &#123; // 根据ID删除数据 this.list.some((item, index) =&gt; &#123; if (item.id == id) &#123; this.list.splice(index,1); return true; &#125; &#125;) &#125; 12345678del2(id) &#123; var index = this.list.findIndex(item=&gt;&#123; if(item.id==id)&#123; return true; &#125; &#125;) this.list.splice(index,1) &#125; 根据索引移除list中的数据(调用数组的splice方法)1this.list.splice(index,1); Vue Devtools安装注意事项 安装方法:去chrome扩展商店搜索vue,第一个就是 安装好之后需要打开允许本地文件,否则无法使用 必须使用vue.js而不是vue.min.js,否则会报如下错误Devtools inspection is not available because it&#39;s in production mode or explicitly disabled by the author. 搜索功能开发 之前v-for中的数据都是从data中的list直接获取到的,现在我们需要自定义一个search方法,同时把搜索的关键字通过参数传递给search方法. 在search方法内部,通过for循环把所有符合搜索关键字的数据保存到一个新数组中返回12345678&lt;tbody&gt; &lt;tr v-for=&quot;item in search(keyWords)&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; 12345678910111213141516171819search(keywords) &#123; var result = [] this.list.forEach(element =&gt; &#123; if (element.name.indexOf(keywords) != -1) &#123; result.push(element); &#125; &#125;); return result;&#125;search2(keywords) &#123; var result = this.list.filter(item =&gt; &#123; // ES6中为字符串提供一个新方法:string.prototype.includes('要包含的字符串') // 如果包含返回true,否则返回false if (item.name.includes(keywords)) &#123; return true; &#125; &#125;) return result;&#125; forEach some filter findIndex 这些都属于数组的新方法,都会对数组中的每一项进行遍历,执行相关操作; Vue中全局过滤器的使用过滤器概念:Vue允许自定义过滤器,可被用于一些常见的文本格式化.过滤器可以用在两个地方:mustache插值和v-bind表达式.过滤器应该被添加在JavaScript表达式的尾部,由”管道|”符指示; 123Vue.filter('过滤器名称', function(data,)&#123; &#125;) 过滤器中的function第一个参数已经规定死了,永远都是过滤器管道符前面传递过来的数据 所谓的全局过滤器就是所有的vm实例都共享的12345&lt;p&gt;&#123;&#123; msg | msgformat(&apos;大熊&apos;) &#125;&#125;&lt;/p&gt;// 字符串的replace方法第一个参数除了可以写字符串还可以写正则 Vue.filter(&apos;msgformat&apos;, function (msg,arg) &#123; return msg.replace(/本熊/g,arg) &#125;) 自定义一个私有的过滤器123456789101112131415161718192021222324252627&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; time:new Date() &#125;, methods: &#123; &#125;, filters: &#123; dateFormat: function (date, pattern=&apos;&apos;) &#123; var time = new Date(date) var year = time.getFullYear() var month = time.getMonth()+1 var day = time.getDate() if(pattern.toLowerCase()===&apos;yyyy-mm-dd&apos;)&#123; return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` &#125;else&#123; var hour = time.getHours(); var minute = time.getMinutes(); var second = time.getSeconds(); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;` &#125; &#125; &#125; &#125;); &lt;/script&gt; filters定义私有过滤器,过滤器有两个条件:过滤器名称和处理函数 过滤器调用的时候采用就近原则,如果私有过滤器与全局过滤器名称一致,则优先调用私有过滤器自定义按键修饰符 1234&lt;label&gt; name: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot; @keyup.enter=&quot;add&quot;&gt;&lt;/label&gt; Vue提供的全部的按键别名: .enter .tab .delete (捕获”删除”和”退格键”) .esc .space .up .down .left .right全局指令使用 Vue.directive() 定义全局指令其中: 参数1:指令的名称,在定义的时候,指令的名称前面不需要加v-前缀,在调用的时候,必须在指令名称前加上v-前缀进行调用 参数2:是一个对象,这个对象身上有一些指令相关的hook函数,这些函数可以在特定的阶段执行相关的操作 Vue中所有的指令,在调用的时候,都以v-开头 12 钩子函数 bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted:被绑定元素插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)。 update:所在组件的 VNode 更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated:指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind:只调用一次，指令与元素解绑时调用。 123456789101112Vue.directive('focus', &#123; bind: function (el,binding) &#123; // 每当指令绑定到元素上的时候会执行这个bind函数,只执行一次 // 在每个函数中第一个参数永远是el,表示被绑定的指令的那个元素,这个el参数是一个原生的JS对象 el.focus()// 在元素绑定了指令的时候,还没有插入到DOM中,这时候调用focus方法没有用 &#125;, inserted: function (el) &#123;// 表示元素插入到DOM中的时候会执行inserted函数,触发一次 el.focus() &#125;, updated: function () &#123;// 当VNode更新的时候会执行update,可能会触发多次 &#125;&#125;) el:表示被绑定的指令的那个元素 在每个函数中第一个参数永远是el,表示被绑定的指令的那个元素,这个el参数是一个原生的JS对象 在元素绑定了指令的时候,还没有插入到DOM中,这时候调用focus方法没有用 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) Vue实例的生命周期 主要生命周期函数分类: 创建期间的生命周期函数: beforeCreate:实例刚在内存中被创建出来,此时,还没有初始化好data和methods created:实例已经在内存中创建完成,此时data和method已经创建完成,此时还没有开始编译模板 beforeMount:此函数执行的时候,模板已经在内存中编译好了,但尚未挂载到页面中,此时页面还是旧的 mounted:此时已经将编译好的模板挂载到页面指定容器中显示 运行期间生命周期函数: beforeUpdate:状态更新之前执行此函数,此时data中的数据值是最新的,但是页面上显示的数据还是旧的,因为此时还没开始将最新数据渲染到页面 updated:实例更新完毕后调用此函数,此时data中的数据和页面上的数据值都已完成更新,界面已重新渲染好了 销毁期间的生命周期函数: beforeDestroy:实例销毁之前调用,在这一步实例可以完全被使用 destroyed:Vue实例销毁后调用,调用后,Vue实例指示的所有东西都会解绑,所有的事件监听器会被移除,所有的子实例也会被消毁 如果要调用data中的数据或者使用methods中的方法,最早只能在created中进行操作mounted是实例创建期间的最后一个生命周期函数,当执行完mounted就表示实例已经被完全创建好了,此时,如果没有其他操作的话,这个实例就静静的呆在内存中如果要通过某些插件操作页面上的DOM节点,最早要在mounted中做 vue-resource发起请求除了vue-resource还可以用axics的第三方包发起请求 123456789101112131415&#123; // GET /someUrl this.$http.get('/someUrl').then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;);&#125;// global Vue objectVue.http.get('/someUrl', [config]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);// in a Vue instancethis.$http.get('/someUrl', [config]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback); methods: get(url, [config]) head(url, [config]) delete(url, [config]) jsonp(url, [config]) post(url, [body], [config]) put(url, [body], [config]) patch(url, [body], [config])jsonp实现原理 由于浏览器安全限制,不允许ajax访问协议不同,域名不同,端口不同的数据接口,浏览器认为这种方式不安全 可以通过动态创建script标签的形式,把script标签的src属性指向数据接口的地址,因为script标签不存在跨域限制,这种数据获取方式称为jsonpjsonp只支持Get请求具体实现过程: 先在客户端定义一个回调方法,预定义数据的操作 再把这个方法的名称通过url传参的形式传递给服务器端的数据接口 服务器数据接口组织好要发送给客户端的数据,再拿着客户端传递过来的方法名称拼接出一个调用这个方法的字符串,发送给客户端去解析执行 客户端拿到服务器返回的字符串后,当做script脚本去解析执行,这样就能拿到jsonp的数据了服务端代码如下:12345678910111213141516171819202122var http = require('http');var urlModel = require('url');http.createServer(function (request, response) &#123; const &#123;pathname:url,query&#125;=urlModel.parse(request.url,true) if (url == '/getscript') &#123; // 拼接一个合法的JS脚本,这里拼接一个show方法的调用 //var scriptStr = 'show()' var girl = &#123; name:'小红', age:18 &#125; var scriptStr = `$&#123;query.callback&#125;($&#123;JSON.stringify(girl)&#125;)` // response.end 发送给客户端,客户端去把这个字符串当做JS代码去解析执行 response.end(scriptStr) &#125; else &#123; response.end('404') &#125;&#125;).listen(8081);console.log('Server running at http://127.0.0.1:8081/'); 客户端的代码如下: 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="lib/vue.js"&gt;&lt;/script&gt; &lt;script src="lib\vue-resource.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="lib\bootstrap\css\bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function show(data) &#123; console.log(data); &#125; &lt;/script&gt; &lt;script src="http://127.0.0.1:8081/getscript?callback=show"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; msg: 'ok' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑马Vue学习笔记]]></title>
    <url>%2F2019%2F08%2F12%2Fvue-study-01%2F</url>
    <content type="text"><![CDATA[Hello World Vue 引入Vue.js文件 1&lt;script src="lib/vue.min.js"&gt;&lt;/script&gt; 在页面创建一个需要被控制的div区域 123&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 创建一个Vue实例 123456789&lt;script&gt; var vm = new Vue(&#123; el: "#app", // 表示当面new的vue实例要控制页面的哪个区域 这里的data就是MVVM中的M,专门用来保存每个页面的数据 data: &#123; msg:'欢迎学习vue' &#125; &#125;); &lt;/script&gt; ‘el’表示当前创建的Vue实例控制页面的哪个区域data中存放el要用到的数据通过Vue提供的命令,很方便把数据渲染到页面中,我们不需再手动操作绑定DOM元素赋值了,(Vue等框架不提倡我们手动操作DOM元素) 我们new出来的vm对象就是MVVM中的VM调度者 属性绑定相关 12345&lt;style&gt; [v-cloak] &#123; display: none; &#125;&lt;/style&gt; 通过v-cloak能够解决插值表达式闪烁的问题,默认v-text没用闪烁问题 v-html能够将内容解析成HTML v-bind 是Vue中提供绑定属性的指令,可以缩写为:要绑定的属性,v-bind可以写合法的js表达式 按钮事件绑定 Vue提供v-on: 事件绑定机制,缩写为@事件123456789101112131415&lt;input type="button" v-on:click="show" value="Start"&gt;&lt;/button&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", // 表示当面new的vue实例要控制页面的哪个区域 data: &#123; msg:'欢迎学习vue' &#125;, methods:&#123; show:function()&#123; alert('Hello'); &#125; &#125; &#125;); &lt;/script&gt; 走马灯Demo 给按钮绑定一个点击事件 在开始按钮的处理函数中,写业务逻辑代码:拿到msg字符串调用字符串substring方法进行字符串截取操作,把第一个字符截取出来,放到最后一个位置,为了实现跑马灯效果需要把上述代码放入定时器中执行 在vm实例中想要获取data上的数据或者调用methods中的方法必须通过this.属性名或this.方法名来进行访问,this就表示我们new出来的vm实例 VM实例会监听自己data中的数据变化,只要一发生数据变化就会自动把最新数据从data中渲染到页面中 事件修饰符 stop阻止冒泡 prevent阻止默认事件 capture添加事件侦听器时使用事件捕获模式 .self只当事件在该元素本身(比如不是子元素)触发时触发回调 .once 事件只触发一次1234567891011&lt;div id="app" class="inner" @click="divHandler"&gt; &lt;!-- 使用.stop阻止冒泡 --&gt; &lt;input type="button" value="Button" @click.stop="btnHander" /&gt; &lt;!-- 使用.prevent阻止默认行为 --&gt; &lt;a href="http://www.baidu.com" @click.prevent="linkClick"&gt;baidu一下&lt;/a&gt; &lt;/div&gt; &lt;!-- 使用.capture 实现捕获触发事件的机制--&gt; &lt;div id="app" class="inner" @click="divHandler"&gt; &lt;!-- 使用.stop阻止冒泡 --&gt; &lt;input type="button" value="Button" @click.stop="btnHander" /&gt;&lt;/div&gt; v-model 双向数据绑定指令 v-bind 只能实现数据的单向绑定,从Model自动绑定到View中,无法实现数据的双向绑定 使用v-model可以实现表单元素和Model中数据的双向绑定 v-model 只能运用在表单元素中1&lt;input type="text" v-model="msg" style="width: 100%"&gt; v-model 实例 简易计算器123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;input type="text" v-model="x1" /&gt; &lt;select v-model="opt"&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="x2" /&gt; &lt;input type="button" value="=" @click="calc" /&gt; &lt;input type="text" v-model="ans" /&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; x1: 0, x2: 0, ans: 0, opt: "+" &#125;, methods: &#123; calc() &#123; switch (this.opt) &#123; case "+": this.ans = parseInt(this.x1)+parseInt(this.x2) break; case "-": this.ans = parseInt(this.x1)-parseInt(this.x2) break; case "*": this.ans = parseInt(this.x1)*parseInt(this.x2) break; case "/": this.ans = parseInt(this.x1)/parseInt(this.x2) break; &#125; &#125; &#125; &#125;); &lt;/script&gt; Vue中的样式class 直接传递一个数组,注意:这里的class需要用v-bind进行绑定 123456789101112131415&lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;h1 :class=['thin','active']&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 在数组中使用三元表达式 1&lt;h1 :class=['thin',flag?'active':'']&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 其中的flag是data中创建的布尔属性 在数组中使用对象来代替三元表达式,提高代码可读性 1&lt;h1 :class=['thin',&#123;'active':flag&#125;]&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 直接绑定对象 1&lt;h1 :class=&#123;red:flag&#125;&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 当为class使用v-bind绑定对象的时候,对象的属性是类名,由于对象属性可带引号也可不带引号,所以red可以不写引号,属性的值是一个标识符 1&lt;h1 :class="classList"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 1classList:&#123;thin:true,red:true&#125; 内联样式的使用 直接在元素上通过:style书写样式对象 将样式对象定义到data中,并直接引用到:style中 12345h1 :style="styleList"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt;data:&#123; styleList:&#123;color:'blue','font-size':'120px'&#125;&#125; 在:style中通过数组,引用多个data上的样式对象 1&lt;h1 :style="[styleList,style2List]"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 1234data:&#123; styleList:&#123;color:'blue','font-size':'120px'&#125;, style2List:&#123;'font-weight':50&#125;&#125; v-for循环的使用 简单数据1234567891011&lt;div id="app"&gt; &lt;p v-for="item in list"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; list: [1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125;); &lt;/script&gt; 其中item可替换成(item,index),index为索引值 循环对象123456789101112131415161718192021&lt;p v-for="(value,key) in user"&gt;&#123;&#123; key &#125;&#125;---&#123;&#123; value &#125;&#125;&lt;/p&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; list: [1, 2, 3, 4, 5, 6, 7, 8], user:&#123; id:1, name:'john mayer', gender:'man' &#125; &#125; &#125;);&lt;/script&gt;``` **在遍历对象身上的键值对的时候,除了key和value,在第三个位置还有index索引**3. 循环迭代数据```html &lt;p v-for="count in 10"&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; 用v-for 迭代数字注意count值从1开始 v-for 使用注意事项 在vue 2.2.0+ 版本中,当在组件中使用v-for时,key值是必须的,用v-bind:key的形式指定key的值 v-for 循环的时候,key只能用string或者number 1&lt;p v-for="item in list" :key="item"&gt; v-if与v-show的使用 v-if 每次都会删除或创建节点,有较高的切换性能消耗 v-show 每次不会删除或创建节点,只是切换了元素的display:none的样式,有较高的初始渲染消耗 如果元素涉及到频繁的切换,最好不用v-if而是推荐使用v-show,如果元素可能永远也不会被显示出来给用户看到,则推荐使用v-if]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成MyBatis]]></title>
    <url>%2F2019%2F08%2F02%2FspringbootMybatis%2F</url>
    <content type="text"><![CDATA[参考MyBatis官网 1. 添加maven依赖添加到pom.xml 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2. 配置MySQL连接编辑application.properties这个文件,我用的xampp中的MySQL所以root密码为空,我的数据库名字叫”discuss” 1234spring.datasource.url=jdbc:mysql://localhost/discuss?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 到此为止MyBatis就算是整合进来了,下面我们来测试一下是否成功 验证在数据库中添加一个user的表12345678910111213SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `nickname` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; 编写一个User的model1234567public class User &#123; private Integer id; private String username; private String password; private String nickname;&#125; 包含了id,username,password,nickname这四个属性,请自行alt+insert生成getter和setter方法 编写一个mapper12345678@Mapperpublic interface UserMapper &#123; //@Select("SELECT id,username,password,nickname FROM USER") //User find(); @Insert("INSERT INTO USER (USERNAME,PASSWORD,NICKNAME) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;nickname&#125;)") void insert(User user);&#125; 在Controller中添加一个测试方法首先要注入mapper 123456789101112@AutowiredUserMapper userMapper;@RequestMapping("/addUser")public String add()&#123; User user = new User(); user.setUsername("admin"); user.setPassword("admin123"); user.setNickname("管理员"); userMapper.insert(user); return "index";&#125; 之后浏览器访问:”http://localhost:8080/addUser&quot;再查看数据库中的user表,如果有数据说明我们MyBatis整合成功 注意点 连接MySQL数据库时一定要指定好时区和编码,不然会报错 之前开发SSM时习惯于将Controller统一放到包里,但是Spring Boot默认却无法识别提示conflict,只能暂时将controller跟SpringBootApplication放到同一目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下安装hexo的过程]]></title>
    <url>%2F2019%2F07%2F31%2Fmy%20first%20blog%2F</url>
    <content type="text"><![CDATA[Quick Start首先你的电脑需要安装node.js和Git安装好Git之后需要配置本机与Github之间的ssh方便更新同步博客到Github上，在一个地方新建一个文件夹作为我们博客的根目录,在文件夹内右键选择Git bash here 123456git config --global user.name "你的GitHub注册名"# 回车git config --global user.email "你的Github注册邮箱"# 回车ssh-keygen -t rsa -C "你的GitHub注册邮箱"# 三个回车，保持默认就行，如果成功会出现一堆字符一样的画面 并且会在C:\Users\你的用户名.ssh\下生成id_rsa.pub这个文件，用记事本打开复制其中的内容到Github网站设置页面中的SSH and GPG keys标签，点击右上角的New SSH Key添加一个新key，然后在bash中运行 1ssh git@github.com 如果提示如下那么说明SSH Key配置正确 用npm安装hexo相关包到你的电脑上1npm install -g hexo-cli 初始化hexo博客系统1hexo init 生成静态文件1hexo g 本地运行博客系统1hexo s 浏览器访问http:localhost:4000即可成功打开本地的博客页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot集成MyBatis小记]]></title>
    <url>%2F2020%2F05%2F11%2FSpringBoot%E9%9B%86%E6%88%90MyBatis%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SpringBoot集成MyBatis小记参考MyBatis官网 1. 添加maven依赖添加到pom.xml 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2. 配置MySQL连接编辑application.properties这个文件,我用的xampp中的MySQL所以root密码为空,我的数据库名字叫”discuss” 1234spring.datasource.url=jdbc:mysql://localhost/discuss?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 到此为止MyBatis就算是整合进来了,下面我们来测试一下是否成功 验证在数据库中添加一个user的表12345678910111213SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `nickname` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; 编写一个User的model1234567public class User &#123; private Integer id; private String username; private String password; private String nickname;&#125; 包含了id,username,password,nickname这四个属性,请自行alt+insert生成getter和setter方法 编写一个mapper12345678@Mapperpublic interface UserMapper &#123; //@Select("SELECT id,username,password,nickname FROM USER") //User find(); @Insert("INSERT INTO USER (USERNAME,PASSWORD,NICKNAME) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;nickname&#125;)") void insert(User user);&#125; 在Controller中添加一个测试方法首先要注入mapper 123456789101112@AutowiredUserMapper userMapper;@RequestMapping("/addUser")public String add()&#123; User user = new User(); user.setUsername("admin"); user.setPassword("admin123"); user.setNickname("管理员"); userMapper.insert(user); return "index";&#125; 之后浏览器访问:”http://localhost:8080/addUser&quot;再查看数据库中的user表,如果有数据说明我们MyBatis整合成功 注意点 连接MySQL数据库时一定要指定好时区和编码,不然会报错 之前开发SSM时习惯于将Controller统一放到包里,但是Spring Boot默认却无法识别提示conflict,只能暂时将controller跟SpringBootApplication放到同一目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[SimpleImputer 中fit和transform方法的简介]]></title>
    <url>%2F2020%2F05%2F11%2Fsklearn.impute.SimpleImputer%20%E4%B8%ADfit%E5%92%8Ctransform%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[sklearn.impute.SimpleImputer 中fit和transform方法的简介SimpleImputer 简介通过SimpleImputer ，可以将现实数据中缺失的值通过同一列的均值、中值、或者众数补充起来，这里用均值举例。 fit方法通过fit方法可以计算矩阵缺失的相关值的大小，以便填充其他缺失数据矩阵时进行使用。 12345import numpy as npfrom sklearn.impute import SimpleImputerimp = SimpleImputer(missing_values=np.nan, strategy='mean')imp.fit([[1, 2], [np.nan, 3], [7, 6]]) 对于数组 1234567$$ \begin&#123;matrix&#125; 1 &amp; 2 \\ null &amp; 3 \\ 7 &amp; 6 \\ \end&#123;matrix&#125; $$ 经过imp.fit之后，第一列的均值为(1+7)/2=4,第二列的均值为(2+3+6)/3=3.6667。 12X = [[np.nan, 2], [6, np.nan], [7, 6]]print(imp.transform(X)) transform 方法之后给定一个X矩阵，通过transform方法进行转换。$$\begin{matrix} null &amp; 2 \ 6 &amp; null \ 7 &amp; 6 \ \end{matrix}$$填充第一个null为之前算的均值4，第二null为第二列均值3.6667 fit_transform 方法一般我们实际使用时，对于给定的数据，直接使用fit_transform方法进行计算以及填充。]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下安装hexo的过程]]></title>
    <url>%2F2020%2F05%2F11%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B%E5%AE%89%E8%A3%85hexo%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[记录一下安装hexo的过程1. 首先你的电脑需要安装node.js和Git2. 安装好Git之后需要配置本机与Github之间的ssh方便更新同步博客到Github上，在一个地方新建一个文件夹作为我们博客的根目录,在文件夹内右键选择Git bash here123456git config --global user.name "你的GitHub注册名"# 回车git config --global user.email "你的Github注册邮箱"# 回车ssh-keygen -t rsa -C "你的GitHub注册邮箱"# 三个回车，保持默认就行，如果成功会出现一堆字符一样的画面 并且会在C:\Users\你的用户名.ssh\下生成id_rsa.pub这个文件，用记事本打开复制其中的内容到Github网站设置页面中的SSH and GPG keys标签，点击右上角的New SSH Key添加一个新key，然后在bash中运行 1ssh git@github.com 如果提示如下那么说明SSH Key配置正确 3. 用以下npm命令安装hexo相关包到你的电脑上1npm install -g hexo-cli 4. 初始化hexo博客系统1hexo init 5. 生成静态文件1hexo g 6. 本地运行博客系统1hexo s 用浏览器访问http:localhost:4000即可成功打开本地的博客页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑马Vue学习笔记04]]></title>
    <url>%2F2019%2F11%2F22%2Fvue-study-04%2F</url>
    <content type="text"><![CDATA[父组件向子组件传值 父组件可以在引用子组件的时候,通过属性绑定v-bing的形式,把需要传递给子组件的数据,以属性绑定的形式传递到子组件的内部,供子组件使用 把父组件传递过来的数据属性,现在props数组中定义一下,这样才能使用这个数据 注意:组件中的所有props中的数据,都是通过父组件传递给子组件的.子组件中的data数据,并不是通过父组件传递过来的,而是子组件自己私有的,比如子组件通过Ajax请求回来的数据,都可以放到data中.data中的数据都是可读可写的,props中的数据是只读的 12345678910111213141516171819202122 var vm = new Vue(&#123; el: "#app", data: &#123; msg: '啊 父组件中的数据' &#125;, methods: &#123; &#125;, components: &#123; com1: &#123; data()&#123; return &#123; title:'title22', content:'some words' &#125; &#125;, template: '&lt;h1&gt;这是子组件&#123;&#123;parentmsg&#125;&#125;&lt;/h1&gt;', props: ['parentmsg'] &#125; &#125;&#125;); 父组件向子组件传递方法父组件向子组件传递方法,使用的是事件绑定机制;v-on可缩写为@当我们自定义了一个事件属性之后,那么,子组件就能够通过某些方式来调用传递进去的方法了 1234567891011121314151617181920212223242526&lt;script&gt; var com2 = &#123; template: &apos;#tmp1&apos;, methods: &#123; myclick() &#123; console.log(&apos;ok&apos;) this.$emit(&apos;fff&apos;); &#125; &#125;, &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &apos;啊 父组件中的数据&apos; &#125;, methods: &#123; show()&#123; console.log(&apos;调用了父组件身上的show方法&apos;) &#125; &#125;, components: &#123; com2 &#125; &#125;);&lt;/script&gt; 回复功能demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;div id=&quot;app&quot;&gt; &lt;cmt-box @func=&quot;loadComments&quot;&gt;&lt;/cmt-box&gt; &lt;ul class=&quot;list-group&quot;&gt; &lt;li class=&quot;list-group-item&quot; v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;badge&quot;&gt;评论人:&#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;template id=&quot;tmp1&quot;&gt; &lt;div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;评论人:&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;user&quot;&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;&quot;&gt;评论内容:&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; v-model=&quot;content&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;发表&quot; @click=&quot;send&quot; class=&quot;btn btn-primary&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; var commentBox = &#123; template: &apos;#tmp1&apos;, data: function () &#123; return &#123; user: &apos;&apos;, content: &apos;&apos; &#125; &#125;, methods: &#123; send() &#123; var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) list.unshift(comment) localStorage.setItem(&apos;cmts&apos;, JSON.stringify(list)) this.user = this.content = &apos;&apos; this.$emit(&apos;func&apos;) &#125; &#125; &#125; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list: [] &#125;, created() &#123; var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list &#125;, methods: &#123; loadComments() &#123; var list = JSON.parse(localStorage.getItem(&apos;cmts&apos;) || &apos;[]&apos;) this.list = list &#125; &#125;, components: &#123; &apos;cmt-box&apos;: commentBox &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由:对于普通的网站,所有的超链接都是url地址,所有的url地址都对应服务器上对应的资源 前端路由:对于单页面应用程序来说,主要通过url中的hash(#号)来实现不同页面之间切换,同时,hash有一个特点,http请求中不会包含hash中的内容;所以单页面程序中的页面跳转主要用hash实现; 在单页面应用中,这种通过hash改变来切换页面的方式,称作前端路由(区别于后端路由);在vue中使用vue-router路由的基本使用 安装vue-router路由模块 创建一个路由对象,当导入一个vue-router包之后,在windows的全局对象中就有了一个路由的构造函数,叫做VueRouter.在new路由对象的时候,可以为构造函数传递一个配置对象12345const router = new VueRouter(&#123; routes:[ &#123; &#125; ] &#125;) routes 表示路由匹配规则的意思 每个路由规则,都是一个对象,这个规则对象身上有两个必须的属性: path:表示监听哪个路由链接地址 component:表示如果路由是前面匹配到的path,则展示component属性对应的组件component的属性值必须是一个组件模板对象,不能是组件模板的引用名称 将路由规则对象,注册到vm实例上,用来监听URL地址的变化,然后展示对应的组件 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;login&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: &apos;&lt;h1&gt;这是登录组件&lt;/h1&gt;&apos; &#125; var register = &#123; template: &apos;&lt;h1&gt;这是注册组件&lt;/h1&gt;&apos; &#125; const router = new VueRouter(&#123; routes: [&#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ] &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, router: router &#125;); &lt;/script&gt;&lt;/div&gt; router-view是vue-router 提供的元素,专门用来当做占位符的,将来路由规则匹配到的组件就会展示到这个router-view中,认为是一个占位符 router-link 默认渲染为&lt;a&gt;标签 linkActiveClass:&#39;btn&#39;可以设定自定义激活类 路由规则中定义参数 如果在路由中使用查询字符串给路由传递参数,则不需要修改路由规则的path属性 1234567&lt;router-link to=&quot;/login?id=110&quot;&gt;login&lt;/router-link&gt;var login = &#123; template: &apos;&lt;h1&gt;这是登录组件&#123;&#123;this.$route.query.id&#125;&#125;&lt;/h1&gt;&apos;, created() &#123; console.log(this.$route) &#125;,&#125; 路由规则传递方式212345678910111213141516&lt;router-link to=&quot;/login/12&quot;&gt;login&lt;/router-link&gt;const router = new VueRouter(&#123; routes: [&#123; path: &apos;/login/:id&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125;, &#123; path:&apos;/&apos;, redirect:&apos;/login&apos; &#125; ]&#125;) 子路由 使用children属性实现子路由,同时,子路由的path前面不要带/,否则永远以根路径开始请求,这样不方便用户去理解url地址使用命名视图实现经典布局12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 &lt;style&gt; html,body &#123; margin: 0px; padding: 0px; &#125; h1 &#123; margin: 0; padding: 0; font-size: 16px; &#125; .header &#123; background-color: orange; height: 80px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightblue; flex: 2; &#125; .main &#123; background-color: lightgreen; flex: 8; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;container&quot;&gt; &lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var header = &#123; template: &apos;&lt;h1 class=&quot;header&quot;&gt;Header area&lt;/h1&gt;&apos; &#125; var leftBox = &#123; template: &apos;&lt;h1 class=&quot;left&quot;&gt;Left area&lt;/h1&gt;&apos; &#125; var mainBox = &#123; template: &apos;&lt;h1 class=&quot;main&quot;&gt;Main area&lt;/h1&gt;&apos; &#125; const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; &apos;default&apos;: header, &apos;left&apos;: leftBox, &apos;main&apos;: mainBox &#125; &#125; ], &#125;) var vm = new Vue(&#123; el: &quot;#app&quot;, router: router &#125;);&lt;/script&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 上传和下载文件]]></title>
    <url>%2F2019%2F10%2F11%2Fupload-download%2F</url>
    <content type="text"><![CDATA[上传文件1234567891011121314151617181920@Value("$&#123;pdf.path&#125;")private String path;@RequestMapping(value = "/upload",method = RequestMethod.POST) public RespBean upload(MultipartFile file, Questionnaire questionnaire) &#123; String fileName = file.getOriginalFilename(); String suffixName = fileName.substring(fileName.lastIndexOf(".")); fileName = UUID.randomUUID()+suffixName; try &#123; file.transferTo(new File(path+fileName)); questionnaire.setCreateTime(new Date()); questionnaire.setPdfPath(path+fileName); questionnaireService.addQuestionnaire(questionnaire); &#125; catch (Exception e) &#123; e.printStackTrace(); return RespBean.error("添加失败"); &#125; return RespBean.ok("添加成功"); &#125; 下载文件1234567891011121314151617181920@RequestMapping(value = "downloadPDF" ,method = RequestMethod.GET) public ResponseEntity&lt;byte[]&gt; downloadPDF(int id) throws IOException &#123; // 读取pdf文件到字节里 Questionnaire questionnaire = questionnaireService.getQuestionnaireById(id); if(questionnaire.getPdfPath()!=null) &#123; Path path = Paths.get(questionnaire.getPdfPath()); byte[] contents = Files.readAllBytes(path); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.parseMediaType("application/pdf")); String fileName = "output.pdf"; headers.add("content-disposition", "inline;filename=" + fileName); headers.setCacheControl("must-revalidate, post-check=0, pre-check=0"); ResponseEntity&lt;byte[]&gt; response = new ResponseEntity&lt;&gt;(contents, headers, HttpStatus.OK); return response; &#125; return null; &#125; 说明： ${pdf.path}是配置在application.properties中的属性，根据操作系统的不同而有所区别，比如： 1234# windowspdf.path=E://# linux# path=/usr/local/temp]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑马Vue学习笔记03]]></title>
    <url>%2F2019%2F09%2F14%2Fvue-study-03%2F</url>
    <content type="text"><![CDATA[vue-resource请求数据注意事项: 练习的时候后台使用的是JAVA,请求的时候报from origin &#39;null&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.这个错误,从中可以知道浏览器为了安全考虑,禁止进行跨域请求,解决办法就是在服务器端的返回中设置一下header即可,代码如下:1response.setHeader("access-Control-Allow-Origin","*"); 1234567891011getAllList()&#123; // 获取所有列表 // 1. 由于已经导入了vue-resource这个包,所以可以直接通过this.$http来发起请求 // 2. 根据接口文档应该发起get请求 // 3. this$http.get('url').then(function(result)&#123;&#125;) // 4. 当通过then指定回调函数后,在回调函数中可以拿到服务器返回的数据 var url = 'http://localhost:8080/getQuestionList' this.$http.get(url).then(result=&gt;&#123; console.log(result.body) &#125;)&#125; 向服务器端添加数据123456789101112131415161718192021222324 add() &#123; // 添加品牌到服务器 // 1. 发送post请求 this.$http.post // 2. this.$http.post 接受三个参数: // 2.1 第一个参数:要请求的url地址 // 2.2 第二个参数:要提交给服务器的数据,要以对象的形式提交给服务器&#123;name:this.name&#125; // 2.3 第三个参数:是一个配置对象,要以哪种表单数据类型提交过去,&#123;emulateJSON:true&#125;以普通表单格式,将数据提交给服务器application/x-www-form-urlencoded // 3. 在post方法中,使用.then来设置成功的回调函数,如果想要拿到成功的结果,需要调用result.body var url = 'http://localhost:8080/addCar' this.$http.post(url, &#123; name: this.name &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; if (result.body.status == 0) &#123; // success this.getAllList() this.name='' &#125; else &#123; //failed alert('添加失败!') &#125; &#125;) &#125;, 服务器端代码: 1234567891011@RequestMapping("/addCar")public ObjDTO addCar(HttpServletResponse response,String name) &#123; response.setHeader("access-Control-Allow-Origin","*"); Car car = new Car(); car.setName(name); car.setCreateTime(String.valueOf(System.currentTimeMillis())); ObjDTO objDTO = new ObjDTO(); objDTO.setStatus(0); carMapper.insert(car); return objDTO;&#125; 如果通过全局配置了请求的数据接口根域名,则在每次单独发起http请求的时候请求的url路径应该以相对路径开头,前面不能带有’/‘,否则不会启用根路径做拼接. 全局配置emulateJSON1Vue.http.options.emulateJSON = true Vue 动画相关 提升用户使用体验 帮助用户更好地理解页面的功能 使用transition元素把需要被动画控制的元素包裹起来,transition内部的元素实现动画元素是Vue官方提供的元素 自定义两组样式来控制transition内部的元素实现动画123456789101112131415161718192021222324&lt;style&gt; .v-enter, /* 这是一个时间点.进入之前元素的其实状态,此时还没有开始进入 */ .v-leave-to &#123; /* 是动画离开之后,离开的终止状态,此时元素动画已经结束了*/ opacity: 0; transform:translateX(8px); &#125; .v-leave-active, /* 离场动画时间段 */ .v-enter-active &#123; /* 入场动画时间段*/ transition: all 0.7s ease; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;input type="button" value="change" @click="flag=!flag"&gt; &lt;transition&gt; &lt;h3 v-show="flag"&gt;这是一个h3&lt;/h3&gt; &lt;/transition&gt;&lt;/div&gt; transition标签可以设置自定义的name,用来区分不同组之间的动画,style中也需将v替换为name值 使用animation.css第三方类设置动画1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;change&quot; @click=&quot;flag=!flag&quot;&gt; &lt;transition enter-active-class=&quot;bounceIn&quot; leave-active-class=&quot;bounceOut&quot; :duration=&quot;&#123;enter:200,leave:400&#125;&quot;&gt; &lt;h3 v-show=&quot;flag&quot;&gt;这是一个h3&lt;/h3&gt; &lt;/transition&gt;&lt;/div&gt; 使用钩子函数模拟小球半场动画动画钩子函数的第一个参数:el表示要执行动画的那个DOM元素,是个原生的JS DOM对象 12345678910111213&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; el.offsetWidth 可以强制动画的刷新done就是afterEnter函数的引用在实现列表过渡动画的时候,如果需要过渡的元素是通过v-for循环渲染出来的,不能使用transition包裹,需要使用transition-group如果要为v-for循环设置动画,必须为每一个元素设置:key给transition-group 添加appear属性,实现页面刚展示的入场效果通过为transition-group设定tag属性,指定 transition-group渲染为指定的元素,如果不指定,默认渲染为span标签 Vue组件组件的出现就是为了拆分Vue实例的代码量,能够让我们以不同的组件来划分不同的功能模块,将来我们需要什么样的功能,就可以去调用对应的功能即可;组件化和模块化的不同: 模块化是从代码逻辑的角度进行划分;方便代码分层开发,保证每个功能模块职能单一; 组件化是从UI界面的角度进行划分的;前端的组件化方便UI组件的重用; 组件创建方式1 使用Vue.extend方式来创建全局的Vue组件 使用Vue.component(‘组件id’) 在页面中通过标签的形式引入组件,注意,组件命名的时候使用驼峰标识,在标签中需要将大写换成小写并在前面加上-12345678910&lt;div id=&quot;app&quot;&gt; &lt;my-com1 /&gt;&lt;/div&gt; var com1= Vue.extend(&#123; template:&apos;&lt;h3&gt;这是使用Vue.extend创建的组件&lt;/h3&gt;&apos; // 通过template属性指定了组件要展示的html结构 &#125;) Vue.component(&apos;myCom1&apos;,com1) Vue.component(&apos;mycom2&apos;,Vue.extend(&#123; template:&apos;&lt;h1&gt;hahah&lt;/h1&gt;&apos; &#125;)) 组件创建方式2123Vue.component(&apos;mycom3&apos;,&#123; template:&apos;&lt;h3&gt;这是使用vue.compount创建的组件&lt;/h3&gt;&apos;&#125;) 组件创建方式3在被控制的#app外面,使用template元素定义组件的模板结构自定义私有组件: 123456789101112131415var vm2 = new Vue(&#123; el: &quot;#app2&quot;, data: &#123; flag: false &#125;, methods: &#123; &#125;, components: &#123; login: &#123; template: &apos;&lt;h1&gt;23333&lt;/h1&gt;&apos; &#125; &#125;&#125;); 如果存在多个组件,组件调用的时候需要写成: 1234&lt;div id=&quot;app2&quot;&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt; 不能写成 12&lt;mycom3 /&gt;&lt;login /&gt; 否则只能第一个组件生效 组件中的data 组件可以有自己的data 实例中的data可以为一个对象组件中的data必须为function 组件中的function内部还必须返回一个对象才行 组件中的data数据使用方式和实例中的data使用方式完全一样组件切换动画1234567891011121314151617181920&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125;&lt;/style&gt;&lt;div id="app"&gt; &lt;a href="" @click.prevent="comName='login'"&gt;登录&lt;/a&gt; &lt;a href="" @click.prevent="comName='register'"&gt;注册&lt;/a&gt; &lt;!-- 通过mode属性设置组件切换时候的模式 --&gt; &lt;transition mode="out-in"&gt; &lt;component :is="comName"&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑马Vue学习笔记02]]></title>
    <url>%2F2019%2F08%2F29%2Fvue-study-02%2F</url>
    <content type="text"><![CDATA[添加数据到列表 直接从data中获取id和name 组织出一个对象 调用数组的方法,将该对象添加到data中的list数组中 在Vue中,已经实现了数据的双向绑定,每当我们修改了data中的数据,Vue会自动将最新数据渲染到页面中去相关核心代码如下1234567891011121314151617181920212223242526272829303132333435363738394041&lt;tr v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; id: &apos;&apos;, name: &apos;&apos;, keyWords: &apos;&apos;, list: [&#123; id: 1, name: &apos;保时捷&apos;, ctime: new Date() &#125;, &#123; id: 2, name: &apos;本田&apos;, ctime: new Date() &#125;, &#123; id: 3, name: &apos;丰田&apos;, ctime: new Date() &#125;, ] &#125;, methods: &#123; add() &#123; this.list.push(&#123; id: this.id, name: this.name, ctime: new Date() &#125;) &#125; &#125; &#125;); &lt;/script&gt; 列表删除操作 根据id找到相关数据的索引在数组的some方法中,如果return true,就会立即终止这个数组的后续循环12345678del(id) &#123; // 根据ID删除数据 this.list.some((item, index) =&gt; &#123; if (item.id == id) &#123; this.list.splice(index,1); return true; &#125; &#125;) &#125; 12345678del2(id) &#123; var index = this.list.findIndex(item=&gt;&#123; if(item.id==id)&#123; return true; &#125; &#125;) this.list.splice(index,1) &#125; 根据索引移除list中的数据(调用数组的splice方法)1this.list.splice(index,1); Vue Devtools安装注意事项 安装方法:去chrome扩展商店搜索vue,第一个就是 安装好之后需要打开允许本地文件,否则无法使用 必须使用vue.js而不是vue.min.js,否则会报如下错误Devtools inspection is not available because it&#39;s in production mode or explicitly disabled by the author. 搜索功能开发 之前v-for中的数据都是从data中的list直接获取到的,现在我们需要自定义一个search方法,同时把搜索的关键字通过参数传递给search方法. 在search方法内部,通过for循环把所有符合搜索关键字的数据保存到一个新数组中返回12345678&lt;tbody&gt; &lt;tr v-for=&quot;item in search(keyWords)&quot; :key=&quot;item.id&quot;&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;Delete&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/tbody&gt; 12345678910111213141516171819search(keywords) &#123; var result = [] this.list.forEach(element =&gt; &#123; if (element.name.indexOf(keywords) != -1) &#123; result.push(element); &#125; &#125;); return result;&#125;search2(keywords) &#123; var result = this.list.filter(item =&gt; &#123; // ES6中为字符串提供一个新方法:string.prototype.includes('要包含的字符串') // 如果包含返回true,否则返回false if (item.name.includes(keywords)) &#123; return true; &#125; &#125;) return result;&#125; forEach some filter findIndex 这些都属于数组的新方法,都会对数组中的每一项进行遍历,执行相关操作; Vue中全局过滤器的使用过滤器概念:Vue允许自定义过滤器,可被用于一些常见的文本格式化.过滤器可以用在两个地方:mustache插值和v-bind表达式.过滤器应该被添加在JavaScript表达式的尾部,由”管道|”符指示; 123Vue.filter('过滤器名称', function(data,)&#123; &#125;) 过滤器中的function第一个参数已经规定死了,永远都是过滤器管道符前面传递过来的数据 所谓的全局过滤器就是所有的vm实例都共享的12345&lt;p&gt;&#123;&#123; msg | msgformat(&apos;大熊&apos;) &#125;&#125;&lt;/p&gt;// 字符串的replace方法第一个参数除了可以写字符串还可以写正则 Vue.filter(&apos;msgformat&apos;, function (msg,arg) &#123; return msg.replace(/本熊/g,arg) &#125;) 自定义一个私有的过滤器123456789101112131415161718192021222324252627&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; time:new Date() &#125;, methods: &#123; &#125;, filters: &#123; dateFormat: function (date, pattern=&apos;&apos;) &#123; var time = new Date(date) var year = time.getFullYear() var month = time.getMonth()+1 var day = time.getDate() if(pattern.toLowerCase()===&apos;yyyy-mm-dd&apos;)&#123; return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` &#125;else&#123; var hour = time.getHours(); var minute = time.getMinutes(); var second = time.getSeconds(); return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125; $&#123;hour&#125;:$&#123;minute&#125;:$&#123;second&#125;` &#125; &#125; &#125; &#125;); &lt;/script&gt; filters定义私有过滤器,过滤器有两个条件:过滤器名称和处理函数 过滤器调用的时候采用就近原则,如果私有过滤器与全局过滤器名称一致,则优先调用私有过滤器自定义按键修饰符 1234&lt;label&gt; name: &lt;input type=&quot;text&quot; class=&quot;form-control&quot; v-model=&quot;name&quot; @keyup.enter=&quot;add&quot;&gt;&lt;/label&gt; Vue提供的全部的按键别名: .enter .tab .delete (捕获”删除”和”退格键”) .esc .space .up .down .left .right全局指令使用 Vue.directive() 定义全局指令其中: 参数1:指令的名称,在定义的时候,指令的名称前面不需要加v-前缀,在调用的时候,必须在指令名称前加上v-前缀进行调用 参数2:是一个对象,这个对象身上有一些指令相关的hook函数,这些函数可以在特定的阶段执行相关的操作 Vue中所有的指令,在调用的时候,都以v-开头 12 钩子函数 bind:只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted:被绑定元素插入父节点时调用(仅保证父节点存在，但不一定已被插入文档中)。 update:所在组件的 VNode 更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated:指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind:只调用一次，指令与元素解绑时调用。 123456789101112Vue.directive('focus', &#123; bind: function (el,binding) &#123; // 每当指令绑定到元素上的时候会执行这个bind函数,只执行一次 // 在每个函数中第一个参数永远是el,表示被绑定的指令的那个元素,这个el参数是一个原生的JS对象 el.focus()// 在元素绑定了指令的时候,还没有插入到DOM中,这时候调用focus方法没有用 &#125;, inserted: function (el) &#123;// 表示元素插入到DOM中的时候会执行inserted函数,触发一次 el.focus() &#125;, updated: function () &#123;// 当VNode更新的时候会执行update,可能会触发多次 &#125;&#125;) el:表示被绑定的指令的那个元素 在每个函数中第一个参数永远是el,表示被绑定的指令的那个元素,这个el参数是一个原生的JS对象 在元素绑定了指令的时候,还没有插入到DOM中,这时候调用focus方法没有用 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。 在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如这样写: 123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) Vue实例的生命周期 主要生命周期函数分类: 创建期间的生命周期函数: beforeCreate:实例刚在内存中被创建出来,此时,还没有初始化好data和methods created:实例已经在内存中创建完成,此时data和method已经创建完成,此时还没有开始编译模板 beforeMount:此函数执行的时候,模板已经在内存中编译好了,但尚未挂载到页面中,此时页面还是旧的 mounted:此时已经将编译好的模板挂载到页面指定容器中显示 运行期间生命周期函数: beforeUpdate:状态更新之前执行此函数,此时data中的数据值是最新的,但是页面上显示的数据还是旧的,因为此时还没开始将最新数据渲染到页面 updated:实例更新完毕后调用此函数,此时data中的数据和页面上的数据值都已完成更新,界面已重新渲染好了 销毁期间的生命周期函数: beforeDestroy:实例销毁之前调用,在这一步实例可以完全被使用 destroyed:Vue实例销毁后调用,调用后,Vue实例指示的所有东西都会解绑,所有的事件监听器会被移除,所有的子实例也会被消毁 如果要调用data中的数据或者使用methods中的方法,最早只能在created中进行操作mounted是实例创建期间的最后一个生命周期函数,当执行完mounted就表示实例已经被完全创建好了,此时,如果没有其他操作的话,这个实例就静静的呆在内存中如果要通过某些插件操作页面上的DOM节点,最早要在mounted中做 vue-resource发起请求除了vue-resource还可以用axics的第三方包发起请求 123456789101112131415&#123; // GET /someUrl this.$http.get('/someUrl').then(response =&gt; &#123; // success callback &#125;, response =&gt; &#123; // error callback &#125;);&#125;// global Vue objectVue.http.get('/someUrl', [config]).then(successCallback, errorCallback);Vue.http.post('/someUrl', [body], [config]).then(successCallback, errorCallback);// in a Vue instancethis.$http.get('/someUrl', [config]).then(successCallback, errorCallback);this.$http.post('/someUrl', [body], [config]).then(successCallback, errorCallback); methods: get(url, [config]) head(url, [config]) delete(url, [config]) jsonp(url, [config]) post(url, [body], [config]) put(url, [body], [config]) patch(url, [body], [config])jsonp实现原理 由于浏览器安全限制,不允许ajax访问协议不同,域名不同,端口不同的数据接口,浏览器认为这种方式不安全 可以通过动态创建script标签的形式,把script标签的src属性指向数据接口的地址,因为script标签不存在跨域限制,这种数据获取方式称为jsonpjsonp只支持Get请求具体实现过程: 先在客户端定义一个回调方法,预定义数据的操作 再把这个方法的名称通过url传参的形式传递给服务器端的数据接口 服务器数据接口组织好要发送给客户端的数据,再拿着客户端传递过来的方法名称拼接出一个调用这个方法的字符串,发送给客户端去解析执行 客户端拿到服务器返回的字符串后,当做script脚本去解析执行,这样就能拿到jsonp的数据了服务端代码如下:12345678910111213141516171819202122var http = require('http');var urlModel = require('url');http.createServer(function (request, response) &#123; const &#123;pathname:url,query&#125;=urlModel.parse(request.url,true) if (url == '/getscript') &#123; // 拼接一个合法的JS脚本,这里拼接一个show方法的调用 //var scriptStr = 'show()' var girl = &#123; name:'小红', age:18 &#125; var scriptStr = `$&#123;query.callback&#125;($&#123;JSON.stringify(girl)&#125;)` // response.end 发送给客户端,客户端去把这个字符串当做JS代码去解析执行 response.end(scriptStr) &#125; else &#123; response.end('404') &#125;&#125;).listen(8081);console.log('Server running at http://127.0.0.1:8081/'); 客户端的代码如下: 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="lib/vue.js"&gt;&lt;/script&gt; &lt;script src="lib\vue-resource.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="lib\bootstrap\css\bootstrap.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function show(data) &#123; console.log(data); &#125; &lt;/script&gt; &lt;script src="http://127.0.0.1:8081/getscript?callback=show"&gt;&lt;/script&gt; &lt;div id="app"&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; msg: 'ok' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑马Vue学习笔记]]></title>
    <url>%2F2019%2F08%2F12%2Fvue-study-01%2F</url>
    <content type="text"><![CDATA[Hello World Vue 引入Vue.js文件 1&lt;script src="lib/vue.min.js"&gt;&lt;/script&gt; 在页面创建一个需要被控制的div区域 123&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt;&lt;/div&gt; 创建一个Vue实例 123456789&lt;script&gt; var vm = new Vue(&#123; el: "#app", // 表示当面new的vue实例要控制页面的哪个区域 这里的data就是MVVM中的M,专门用来保存每个页面的数据 data: &#123; msg:'欢迎学习vue' &#125; &#125;); &lt;/script&gt; ‘el’表示当前创建的Vue实例控制页面的哪个区域data中存放el要用到的数据通过Vue提供的命令,很方便把数据渲染到页面中,我们不需再手动操作绑定DOM元素赋值了,(Vue等框架不提倡我们手动操作DOM元素) 我们new出来的vm对象就是MVVM中的VM调度者 属性绑定相关 12345&lt;style&gt; [v-cloak] &#123; display: none; &#125;&lt;/style&gt; 通过v-cloak能够解决插值表达式闪烁的问题,默认v-text没用闪烁问题 v-html能够将内容解析成HTML v-bind 是Vue中提供绑定属性的指令,可以缩写为:要绑定的属性,v-bind可以写合法的js表达式 按钮事件绑定 Vue提供v-on: 事件绑定机制,缩写为@事件123456789101112131415&lt;input type="button" v-on:click="show" value="Start"&gt;&lt;/button&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", // 表示当面new的vue实例要控制页面的哪个区域 data: &#123; msg:'欢迎学习vue' &#125;, methods:&#123; show:function()&#123; alert('Hello'); &#125; &#125; &#125;); &lt;/script&gt; 走马灯Demo 给按钮绑定一个点击事件 在开始按钮的处理函数中,写业务逻辑代码:拿到msg字符串调用字符串substring方法进行字符串截取操作,把第一个字符截取出来,放到最后一个位置,为了实现跑马灯效果需要把上述代码放入定时器中执行 在vm实例中想要获取data上的数据或者调用methods中的方法必须通过this.属性名或this.方法名来进行访问,this就表示我们new出来的vm实例 VM实例会监听自己data中的数据变化,只要一发生数据变化就会自动把最新数据从data中渲染到页面中 事件修饰符 stop阻止冒泡 prevent阻止默认事件 capture添加事件侦听器时使用事件捕获模式 .self只当事件在该元素本身(比如不是子元素)触发时触发回调 .once 事件只触发一次1234567891011&lt;div id="app" class="inner" @click="divHandler"&gt; &lt;!-- 使用.stop阻止冒泡 --&gt; &lt;input type="button" value="Button" @click.stop="btnHander" /&gt; &lt;!-- 使用.prevent阻止默认行为 --&gt; &lt;a href="http://www.baidu.com" @click.prevent="linkClick"&gt;baidu一下&lt;/a&gt; &lt;/div&gt; &lt;!-- 使用.capture 实现捕获触发事件的机制--&gt; &lt;div id="app" class="inner" @click="divHandler"&gt; &lt;!-- 使用.stop阻止冒泡 --&gt; &lt;input type="button" value="Button" @click.stop="btnHander" /&gt;&lt;/div&gt; v-model 双向数据绑定指令 v-bind 只能实现数据的单向绑定,从Model自动绑定到View中,无法实现数据的双向绑定 使用v-model可以实现表单元素和Model中数据的双向绑定 v-model 只能运用在表单元素中1&lt;input type="text" v-model="msg" style="width: 100%"&gt; v-model 实例 简易计算器123456789101112131415161718192021222324252627282930313233343536373839404142&lt;div id="app"&gt; &lt;input type="text" v-model="x1" /&gt; &lt;select v-model="opt"&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="x2" /&gt; &lt;input type="button" value="=" @click="calc" /&gt; &lt;input type="text" v-model="ans" /&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; x1: 0, x2: 0, ans: 0, opt: "+" &#125;, methods: &#123; calc() &#123; switch (this.opt) &#123; case "+": this.ans = parseInt(this.x1)+parseInt(this.x2) break; case "-": this.ans = parseInt(this.x1)-parseInt(this.x2) break; case "*": this.ans = parseInt(this.x1)*parseInt(this.x2) break; case "/": this.ans = parseInt(this.x1)/parseInt(this.x2) break; &#125; &#125; &#125; &#125;); &lt;/script&gt; Vue中的样式class 直接传递一个数组,注意:这里的class需要用v-bind进行绑定 123456789101112131415&lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 0.5em; &#125; &lt;/style&gt;&lt;h1 :class=['thin','active']&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 在数组中使用三元表达式 1&lt;h1 :class=['thin',flag?'active':'']&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 其中的flag是data中创建的布尔属性 在数组中使用对象来代替三元表达式,提高代码可读性 1&lt;h1 :class=['thin',&#123;'active':flag&#125;]&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 直接绑定对象 1&lt;h1 :class=&#123;red:flag&#125;&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 当为class使用v-bind绑定对象的时候,对象的属性是类名,由于对象属性可带引号也可不带引号,所以red可以不写引号,属性的值是一个标识符 1&lt;h1 :class="classList"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 1classList:&#123;thin:true,red:true&#125; 内联样式的使用 直接在元素上通过:style书写样式对象 将样式对象定义到data中,并直接引用到:style中 12345h1 :style="styleList"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt;data:&#123; styleList:&#123;color:'blue','font-size':'120px'&#125;&#125; 在:style中通过数组,引用多个data上的样式对象 1&lt;h1 :style="[styleList,style2List]"&gt;这是一个特别大的H1,无法想象的大 &lt;/h1&gt; 1234data:&#123; styleList:&#123;color:'blue','font-size':'120px'&#125;, style2List:&#123;'font-weight':50&#125;&#125; v-for循环的使用 简单数据1234567891011&lt;div id="app"&gt; &lt;p v-for="item in list"&gt;&#123;&#123; item &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; list: [1, 2, 3, 4, 5, 6, 7, 8] &#125; &#125;); &lt;/script&gt; 其中item可替换成(item,index),index为索引值 循环对象123456789101112131415161718192021&lt;p v-for="(value,key) in user"&gt;&#123;&#123; key &#125;&#125;---&#123;&#123; value &#125;&#125;&lt;/p&gt;&lt;script&gt; var vm = new Vue(&#123; el: "#app", data: &#123; list: [1, 2, 3, 4, 5, 6, 7, 8], user:&#123; id:1, name:'john mayer', gender:'man' &#125; &#125; &#125;);&lt;/script&gt;``` **在遍历对象身上的键值对的时候,除了key和value,在第三个位置还有index索引**3. 循环迭代数据```html &lt;p v-for="count in 10"&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; 用v-for 迭代数字注意count值从1开始 v-for 使用注意事项 在vue 2.2.0+ 版本中,当在组件中使用v-for时,key值是必须的,用v-bind:key的形式指定key的值 v-for 循环的时候,key只能用string或者number 1&lt;p v-for="item in list" :key="item"&gt; v-if与v-show的使用 v-if 每次都会删除或创建节点,有较高的切换性能消耗 v-show 每次不会删除或创建节点,只是切换了元素的display:none的样式,有较高的初始渲染消耗 如果元素涉及到频繁的切换,最好不用v-if而是推荐使用v-show,如果元素可能永远也不会被显示出来给用户看到,则推荐使用v-if]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成MyBatis]]></title>
    <url>%2F2019%2F08%2F02%2FspringbootMybatis%2F</url>
    <content type="text"><![CDATA[参考MyBatis官网 1. 添加maven依赖添加到pom.xml 12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 2. 配置MySQL连接编辑application.properties这个文件,我用的xampp中的MySQL所以root密码为空,我的数据库名字叫”discuss” 1234spring.datasource.url=jdbc:mysql://localhost/discuss?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver 到此为止MyBatis就算是整合进来了,下面我们来测试一下是否成功 验证在数据库中添加一个user的表12345678910111213SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL, `password` varchar(100) DEFAULT NULL, `nickname` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8; 编写一个User的model1234567public class User &#123; private Integer id; private String username; private String password; private String nickname;&#125; 包含了id,username,password,nickname这四个属性,请自行alt+insert生成getter和setter方法 编写一个mapper12345678@Mapperpublic interface UserMapper &#123; //@Select("SELECT id,username,password,nickname FROM USER") //User find(); @Insert("INSERT INTO USER (USERNAME,PASSWORD,NICKNAME) VALUES(#&#123;username&#125;,#&#123;password&#125;,#&#123;nickname&#125;)") void insert(User user);&#125; 在Controller中添加一个测试方法首先要注入mapper 123456789101112@AutowiredUserMapper userMapper;@RequestMapping("/addUser")public String add()&#123; User user = new User(); user.setUsername("admin"); user.setPassword("admin123"); user.setNickname("管理员"); userMapper.insert(user); return "index";&#125; 之后浏览器访问:”http://localhost:8080/addUser&quot;再查看数据库中的user表,如果有数据说明我们MyBatis整合成功 注意点 连接MySQL数据库时一定要指定好时区和编码,不然会报错 之前开发SSM时习惯于将Controller统一放到包里,但是Spring Boot默认却无法识别提示conflict,只能暂时将controller跟SpringBootApplication放到同一目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[记录一下安装hexo的过程]]></title>
    <url>%2F2019%2F07%2F31%2Fmy%20first%20blog%2F</url>
    <content type="text"><![CDATA[Quick Start首先你的电脑需要安装node.js和Git安装好Git之后需要配置本机与Github之间的ssh方便更新同步博客到Github上，在一个地方新建一个文件夹作为我们博客的根目录,在文件夹内右键选择Git bash here 123456git config --global user.name "你的GitHub注册名"# 回车git config --global user.email "你的Github注册邮箱"# 回车ssh-keygen -t rsa -C "你的GitHub注册邮箱"# 三个回车，保持默认就行，如果成功会出现一堆字符一样的画面 并且会在C:\Users\你的用户名.ssh\下生成id_rsa.pub这个文件，用记事本打开复制其中的内容到Github网站设置页面中的SSH and GPG keys标签，点击右上角的New SSH Key添加一个新key，然后在bash中运行 1ssh git@github.com 如果提示如下那么说明SSH Key配置正确 用npm安装hexo相关包到你的电脑上1npm install -g hexo-cli 初始化hexo博客系统1hexo init 生成静态文件1hexo g 本地运行博客系统1hexo s 浏览器访问http:localhost:4000即可成功打开本地的博客页面]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F31%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
